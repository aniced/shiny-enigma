//=============================================================================
// ■ UTF8 / utf8
//-----------------------------------------------------------------------------
//   A Lua module for UTF-8 encoding and decoding.
//=============================================================================

namespace UTF8 {
	//-------------------------------------------------------------------------
	// ● Module variables
	//-------------------------------------------------------------------------
	const char charpattern[] = {
		'[', 0, '-', 0x7f, (char) 0xc2, '-', (char) 0xf4, ']',
		'[', (char) 0x80, '-', (char) 0xbf, ']', '*'
	};
	//-------------------------------------------------------------------------
	// ● add_encode
	//-------------------------------------------------------------------------
	void add_encode(luaL_Buffer* B, uint32_t ch) {
		if (ch < 0x80) {
			luaL_addchar(B, ch);
		} else {
			uint8_t s[5] = {0, 0, 0, 0, 0};
			if (ch < 0x800) {
				s[0] = 0b11000000 | (ch >> 6);
				s[1] = 0b10000000 | (ch & 0b00111111);
			} else if (ch < 0x10000) {
				s[0] = 0b11100000 | (ch >> 12);
				s[1] = 0b10000000 | ((ch >> 6) & 0b00111111);
				s[2] = 0b10000000 | (ch & 0b00111111);
			} else if (ch < 0x110000) {
				s[0] = 0b11110000 | (ch >> 18);
				s[1] = 0b10000000 | ((ch >> 12) & 0b00111111);
				s[2] = 0b10000000 | ((ch >> 6) & 0b00111111);
				s[3] = 0b10000000 | (ch & 0b00111111);
			} else {
				luaL_error(L,
					"invalid character %" PRIu32 " (0x" PRIX32 ")",
					ch, ch
				);
			}
			luaL_addstring(B, (const char*) s);
		}
	}
	//-------------------------------------------------------------------------
	// ● decode
	//   decode returns the first character codepoint.
	//-------------------------------------------------------------------------
	uint32_t decode(const char* seq) {
		uint8_t* s = (uint8_t*) seq;
		if (*s < 0x80) {
			return *s;
		} else {
			uint32_t ch;
			if (*s < 0b11100000) {
				ch = (uint32_t) (*s++ & 0b00011111) << 6;
				ch |= (*s & 0b00111111);
			} else if (*s < 0b11110000) {
				ch = (uint32_t) (*s++ & 0b00001111) << 12;
				ch = (uint32_t) (*s++ & 0b00111111) << 6;
				ch |= (*s & 0b00111111);
			} else if (*s < 0b11111000) {
				ch = (uint32_t) (*s++ & 0b00000111) << 18;
				ch = (uint32_t) (*s++ & 0b00111111) << 12;
				ch = (uint32_t) (*s++ & 0b00111111) << 6;
				ch |= (*s & 0b00111111);
			} else {
				luaL_error(L, "invalid UTF-8 sequence prefix 0x%" PRIX8, *s);
			}
			return ch;
		}
	}
	//-------------------------------------------------------------------------
	// ● char(...)
	//-------------------------------------------------------------------------
	int _char(lua_State* L) {
		int n = lua_gettop(L);
		luaL_Buffer b;
    luaL_buffinit(L, &b);
    for (int i = 1; i <= n; i++) {
			add_encode(&b, luaL_checkint(L, i));
    }
    luaL_pushresult(&b);
		return 1;
	}
	//-------------------------------------------------------------------------
	// ●
	//-------------------------------------------------------------------------
	//-------------------------------------------------------------------------
	// ●
	//-------------------------------------------------------------------------
	//-------------------------------------------------------------------------
	// ●
	//-------------------------------------------------------------------------
	//-------------------------------------------------------------------------
	// ●
	//-------------------------------------------------------------------------
	//-------------------------------------------------------------------------
	// ● init
	//-------------------------------------------------------------------------
	void init() {
		const luaL_reg reg[] = {
			{"char", _char},
			{"charpattern", NULL},
			//{"codes", codes},
			//{"codepoint", codepoint},
			//{"len", len},
			//{"offset", offset},
			{NULL, NULL}
		};
		luaL_register(L, "utf8", reg);
		lua_pushlstring(L, charpattern, sizeof(charpattern));
		lua_setfield(L, -2, "charpattern");
		lua_pop(L, 1);
	}
}
